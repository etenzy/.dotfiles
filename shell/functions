# Create a new directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# All the dig info
function digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}

# Remove host from known_hosts 
function removehost() {
    ssh-keygen -R "$1"
}

function microtime() {
    gdate +"%Y-%m-%d %H:%M:%S,%5N"
}

# Run artisan
function artisan() {
    php artisan "$@"
}

# Fix permissions of QuickLook plugins
function fixQL() {
    xattr -r -d com.apple.quarantine ~/Library/QuickLook/QL*
}

# Update zsh completions for kubeone
function kubeone_completion() {
    kubeone completion zsh > $ZSH/completions/_kubeone
}

# Update zsh completions for talosctl
function talosctl_completion() {
    talosctl completion zsh > $ZSH/completions/_talosctl
}

# Update zsh completions
function update_completions() {
    mkdir -p $ZSH/completions
    kubeone_completion
    talosctl_completion
}

function backup_home() {
    ANYFAIL=false
    log_task "Creating Backup"

    mkdir -p $HOME/Backup/_temp

    log_task "Copying files" \
        && rsync --info=progress2 --no-i-r -avr \
            --exclude="Library" \
            --exclude="Movies" \
            --exclude="Music" \
            --exclude="Pictures/Photos Library.photoslibrary" \
            --exclude="Downloads" \
            --exclude="Backup" \
            --exclude=".config/colima" \
            --exclude=".k8slens" \
            --exclude=".krew" \
            --exclude=".kube/cache" \
            --exclude=".vscode/extensions" \
            --exclude=".Trash" \
            --exclude="*/.DS_Store" \
            --exclude="*/*.sock" \
            $HOME $HOME/Backup/_temp | grep -o "[0-9]*%" | sed 's/%//' | progressBar | log_progress  \
        && log_task_success \
        || (log_task_fail && ANYFAIL=true)

    log_task "Creating DMG" \
        && dmg $(date "+%Y-%m") "$HOME/Backup/_temp/$(whoami)" "$HOME/Backup/" | progressbar | log_progress \
        && log_task_success \
        || (log_task_fail && ANYFAIL=true)

    log_task "Cleaning up" \
        && rm -rf mkdir -p $HOME/Backup/_temp \
        && log_info "Temporary files removed" \
        && log_task_success \
        || (log_task_fail && ANYFAIL=true)

    if [ "$ANYFAIL" = true ]; then
        log_task_fail "Backup failed"
    else
        log_task_success "$HOME/Backup/$(date "+%Y-%m").dmg"
    fi
}

# List open media
function lsom() {
    lsof -p $(ps aux | grep -i "$1" | grep -v grep | awk '{print $2}') | grep "\.$2" | grep -Eo "/.*" | xargs
}

function spaces_to_x() {
    for f in *\ *; do mv "$f" "${f// /$1}"; done 
}

function x_to_spaces() {
    for f in *$1*; do mv "$f" "${f//$1/ }"; done 
}

function dedup_lines() {
    sort $1 -u -o $1
}

function remove_empty_lines() {
    sed -r '/^\s*$/d' $1
}

function ds_delete() {
    find . -name ".DS_Store" -delete
}

function files_larger_than() {
    find $(pwd) -type f -size +$1 -exec ls -lh {} \; | awk '{print $5 " " $9}' | sort -h
}

function sed_regex() {
    sed -E 's/'"$1"'/'"$2"'/g' $3
}

function only_email_pass() {   
    grep -Eo '^[[:print:]]+\@([[:alnum:]]+\.)+[[:alnum:]]{2,}\:[[:graph:]]+' $1
}

function search() {
    grep -rni "${2:-$(pwd)}" -e $1
}

function respring() {
    for app in "Dock" "Finder" "System Settings" "SizeUp" "SystemUIServer" "cfprefsd"; do
	    killall "${app}" > /dev/null 2>&1
    done
}

function ts() {
    if [ -z "$IS_GNUDATE" ]; then
        if DATE_TEST=$(date --version 2>/dev/null); then
            IS_GNUDATE=true;
        else
            IS_GNUDATE=false;
        fi
    fi

    if [ -t 0 ]; then
        if [ -z "$1" ]; then
            date "+%s"
        else
            if [ $IS_GNUDATE = true ]; then
                date -d "$1" "+%s"
            else
                date -j -f "%a %b %d %T %Z %Y" "$1" "+%s"
            fi
        fi
    else
        while IFS= read -r line; do
            if [ $IS_GNUDATE = true ]; then
                date -d "$line" "+%s"
            else
                date -j -f "%a %b %d %T %Z %Y" "$line" "+%s"
            fi
        done
    fi
}

function ts2date() {
    if [ -z "$IS_GNUDATE" ]; then
        if DATE_TEST=$(date --version 2>/dev/null); then
            IS_GNUDATE=true;
        else
            IS_GNUDATE=false;
        fi
    fi

    if [ -t 0 ]; then
        if [ $IS_GNUDATE = true ]; then
            date -d @$1
        else
            date -r $1
        fi
    else
        while IFS= read -r line; do
            if [ $IS_GNUDATE = true ]; then
                date -d @$line
            else
                date -r $line
            fi
        done
    fi
}

function datetime() {
    if [ -z "$IS_GNUDATE" ]; then
        if DATE_TEST=$(date --version 2>/dev/null); then
            IS_GNUDATE=true;
        else
            IS_GNUDATE=false;
        fi
    fi

    if [ -t 0 ]; then
        if [ -z "$1" ]; then
            date "+%Y-%m-%d %T"
        else
            if [ $IS_GNUDATE = true ]; then
                date -d "$1" "+%Y-%m-%d %T"
            else
                date -j -f "%a %b %d %T %Z %Y" "$1" "+%Y-%m-%d %T"
            fi
        fi
    else
        while IFS= read -r line; do
            if [ $IS_GNUDATE = true ]; then
                date -d "$line" "+%Y-%m-%d %T"
            else
                date -j -f "%a %b %d %T %Z %Y" "$line" "+%Y-%m-%d %T"
            fi
        done
    fi
}

function datetime2date() {
    if [ -z "$IS_GNUDATE" ]; then
        if DATE_TEST=$(date --version 2>/dev/null); then
            IS_GNUDATE=true;
        else
            IS_GNUDATE=false;
        fi
    fi

    if [ -t 0 ]; then
         if [ $IS_GNUDATE = true ]; then
            date -d "$1"
        else
            date -j -f "%Y-%m-%d %H:%M:%S" "$1"
        fi
    else
        while IFS= read -r line; do
            if [ $IS_GNUDATE = true ]; then
                date -d "$line"
            else
                date -j -f "%Y-%m-%d %H:%M:%S" "$line"
            fi
        done
    fi
}

function log_progress() {
    symbolEmpty="⠀"
    symbolFull="⠿"
    if ! [ -t 0 ]; then
        i=1

        symbol=$symbolEmpty
        printf "${TXT_GRAY}$(get_current_time)${TXT_CLEAR} ${TXT_BLUE}$(get_log_indents)${symbol} $(echo 0 | progressBar)${TXT_CLEAR}\r";
        
        while IFS= read -r line; do
            case $((i % 10)) in
                0) symbol="⠋" ;;
                1) symbol="⠙" ;;
                2) symbol="⠹" ;;
                3) symbol="⠸" ;;
                4) symbol="⠼" ;;
                5) symbol="⠴" ;;
                6) symbol="⠦" ;;
                7) symbol="⠧" ;;
                8) symbol="⠇" ;;
                9) symbol="⠏" ;;
            esac

            printf "${TXT_GRAY}$(get_current_time)${TXT_CLEAR} ${TXT_BLUE}$(get_log_indents)${symbol} ${line}${TXT_CLEAR}\r";
            i=$((i+1))
        done

        symbol=$symbolFull
        printf "${TXT_GRAY}$(get_current_time)${TXT_CLEAR} ${TXT_BLUE}$(get_log_indents)${symbol} $(echo 100 | progressBar)${TXT_CLEAR}\r\n";
    fi
}

function render_script() {
    file=$1

    template=$(cat $file)

    for i in "$@"; do
        case $i in
            -r=*|--replace=*)
            search=$(echo ${i#*=} | awk -F'=' '{print $1}')
            replace=$(echo ${i#*=} | awk -F'=' '{print $2}')

            replace=${replace//\\/\\\\}

            template="${template/$search/$replace}"
            shift
            ;;
            *)
            ;;
        esac
    done

    echo "$template"
}

function test-connection-nc() {
    render_script $HOME/.dotfiles/kubernetes/test-connection-nc.sh \
        -r=IPS="$1" \
        -r=PORTS="$2"
}

function test-connection-pg() {
    ports=${2:-5432}
    database=${3:-postgres}
    user=${4:-postgres}

    render_script $HOME/.dotfiles/kubernetes/test-connection-pg.sh \
        -r=IPS="$1" \
        -r=PORTS="$ports" \
        -r=DATABASE="$database" \
        -r=USER="$user"
}

function test-connection-smb() {
    share=${2//\\/\\\\}
    output=${5:-'false'}

    render_script $HOME/.dotfiles/kubernetes/test-connection-smb.sh \
        -r=IP="$1" \
        -r=SHARE="${share//\\/\\\\}" \
        -r=USER="$3" \
        -r=PASSWORD="$4"
}

function kube-debug-ip() {
    kubectl apply -f $HOME/.dotfiles/kubernetes/netshoot.yaml
    kubectl wait --for=condition=ready pod/tmp-shell --timeout=30s \
        && kubectl exec -it tmp-shell -- /bin/sh -c "$(test-connection-nc $1 $2)"
    kubectl delete -f $HOME/.dotfiles/kubernetes/netshoot.yaml --grace-period=0
}

function kube-debug-pg() {
    kubectl apply -f $HOME/.dotfiles/kubernetes/psql.yaml
    kubectl wait --for=condition=ready pod/tmp-shell --timeout=30s \
        && kubectl exec -it tmp-shell -- /bin/sh -c "$(test-connection-pg $1 ${2:-} ${3:-} ${4:-})"
    kubectl delete -f $HOME/.dotfiles/kubernetes/psql.yaml --grace-period=0
}

function kube-debug-smb() {
    kubectl apply -f $HOME/.dotfiles/kubernetes/smb-toolbox.yaml
    kubectl wait --for=condition=ready pod/tmp-shell --timeout=30s \
        && kubectl exec -it tmp-shell -- /bin/sh -c "$(test-connection-smb $1 $2 $3 $4)"
    kubectl delete -f $HOME/.dotfiles/kubernetes/psql.yaml --grace-period=0
}

# zmk_build <build-dir> <board> <shield>
# zmk_build "build/left" "nice_nano_v2" "corne_left nice_view_adapter nice_view"
function zmk_build() {
    west build --pristine --source-dir "$ZMK_PATH/app" --build-dir "$1" --board "$2" -- -DZMK_CONFIG="$ZMK_CONFIG_PATH/config" -DSHIELD="$3"
}

# Print the full command before running kubectl
# function kubectl() { 
#     echo "+ kubectl $@">&2; command kubectl $@;
# }

function kubeconfig-flatten() {
    rename s/:/-/g $(find "$HOME/.kube" -maxdepth 1 -type f -name '*.bk')
    export KUBECONFIG="$(find "$HOME/.kube" -maxdepth 1 -type f -name '*.bk' | tr '\n' ':')$HOME/.kube/config"
    kubectl config view --raw --flatten > $HOME/.kube/config_tmp
    mv $HOME/.kube/config_tmp $HOME/.kube/config
    mv $HOME/.kube/*.bk $HOME/.kube/.backup/
}